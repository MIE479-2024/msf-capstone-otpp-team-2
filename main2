import pandas as pd
from models.cvar import CVaR_optimization
from models.mvo import mvo_optimize
from models.risk_parity import risk_parity
import numpy as np
from scipy.stats import gmean
import sympy as sp

pd.set_option('mode.chained_assignment', None)

def calculate_historical_metrics(data, current_date, lookback_period=126):
    """
    Calculate historical metrics (expected returns, volatility) for bonds.

    Args:
        data (pd.DataFrame): DataFrame with bond data containing ['Date', 'SecurityId', 'DirtyPrice'].
        current_date (datetime): The current date for the investment period.
        lookback_period (int): Number of days to use for historical metrics.

    Returns:
        pd.DataFrame: DataFrame with 'SecurityId', 'ExpectedReturn', and 'StdDev'.
    """
    # Filter historical data within the lookback period
    start_date = current_date - pd.Timedelta(days=lookback_period)
    historical_data = data[(data['Date'] > start_date) & (data['Date'] <= current_date)]
    print(f"historical data: \n{historical_data}")

    metrics = []
    for security_id in historical_data['SecurityId'].unique():
        bond_data = historical_data[historical_data['SecurityId'] == security_id]
        
        # Calculate returns from DirtyPrice
        returns = bond_data['DirtyPrice'].pct_change().dropna()
        if len(returns) > 0:  # Ensure there are sufficient returns to calculate metrics
            expected_return = returns.mean()
            std_dev = returns.std()
        else:
            expected_return = np.nan
            std_dev = np.nan
        
        metrics.append({
            'SecurityId': security_id,
            'HistoricalReturn': expected_return,
            'HistoricalStdDev': std_dev
        })
    
    return pd.DataFrame(metrics)



data = pd.read_csv('bonds_w_exp_returns.csv')
# Check if model is valid and call the corresponding optimization function
data = data.sort_values(by='Date')
data['Date'] = pd.to_datetime(data['Date'])

model = 'cVaR'
constraints = []
# Initial budget to invest ($100,000)
initialVal = 100000  

# Length of investment period 
investPeriod = 1

# Identify the tickers and the dates
tickers = data['SecurityId'].unique()
dates = data['Date'].unique()

n = len(tickers)   # Number of bonds
NoPeriods = len(dates) // investPeriod  

# Preallocate space for portfolio weights (x0 will track turnover)
x = np.zeros([n, NoPeriods])
x0 = np.zeros([n, NoPeriods])

# Preallocate space for portfolio value, turnover, and transaction costs
currentVal = np.zeros([NoPeriods + 1, 1])
currentVal[0] = initialVal
portfolio_returns = np.zeros(NoPeriods)
turnover = np.zeros([NoPeriods, 1])
transaction_costs = np.zeros([NoPeriods, 1])

rf = 0.02 / 365

# Iterate through investment periods
# Iterate through investment periods
for period in range(NoPeriods-126):
    # Determine the current date

    period = period + 126
    current_date = dates[period * investPeriod]
    
    # Calculate historical metrics
    historical_metrics = calculate_historical_metrics(data, current_date)
    
    # Merge metrics with current bond data
    current_bonds = data[data['Date'] == current_date]
    current_bonds = current_bonds.merge(historical_metrics, on='SecurityId')
    print(current_bonds)
    # Check if there are enough data points to proceed
    if current_bonds.empty or current_bonds['ExpectedReturn'].isnull().any().any() or current_bonds['StdDev'].isnull().any().any():
        print(f"Skipping period {period}: insufficient historical data.")
        continue
    
    # Perform optimization
    if model == "MVO":
        weights = mvo_optimize(current_bonds, x0, constraints)
    elif model == "Risk Parity":
        weights = risk_parity(current_bonds, x0, constraints)
    elif model == "cVaR":
        weights = CVaR_optimization(current_bonds, 0.95, 10, constraints)
    else:
        print("Invalid model selected.")
        continue
    
    # Store weights
    if weights== None:
        print("model returned nothing")
    
    x[:, period] = weights
    
    # Portfolio calculations (as in your original code)
    portfolio_return = np.sum(weights * current_bonds['ExpectedReturn'])
    currentVal[period + 1] = currentVal[period] * (1 + portfolio_return)
    portfolio_returns[period] = portfolio_return

    # Turnover and transaction costs (as in your original code)
    turnover[period] = np.sum(np.abs(weights - x0[:, period])) / 2
    # Calculate transaction costs
    turnover_weights = np.abs(weights - x0[:, period])

    transaction_costs[period] = np.sum(turnover_weights * current_bonds['BidAskSpread'].values)
    currentVal[period + 1] -= transaction_costs[period]
    x0[:, period] = weights



excess_returns = portfolio_returns - rf

# Calculate Sharpe ratio
SR = (gmean(excess_returns + 1) - 1) / excess_returns.std()

# Average turnover and cumulative transaction cost
avgTurnover = np.mean(turnover[1:])
total_transaction_cost = np.sum(transaction_costs)

print('Sharpe ratio: ', str(SR))
print('Avg. turnover: ', str(avgTurnover))
print('Total transaction costs: ', str(total_transaction_cost))

