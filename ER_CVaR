def ER_CVaR_optimization(bond_data, alpha=0.95, lambda_penalty=10):
    N = len(bond_data)  # Number of bonds based on the DataFrame length
    W_max = 1.0  # Maximum weight for the portfolio
    M = W_max  # Maximum weight for any single bond

    # Calculate additional fields
    bond_data['DTS'] = bond_data['duration'] * bond_data['OAS']
    bond_data['transaction_cost'] = bond_data['ask_price'] - bond_data['bid_price']
    expected_returns = np.array(bond_data["expected_return"])
    bond_data['OAS'] = pd.to_numeric(bond_data['OAS'], errors='coerce')

    # Create the model
    model = gp.Model("CVaR_Bond_Optimization")

    model.setParam('OutputFlag', 0)

    # Decision variables
    w = model.addVars(N, vtype=GRB.CONTINUOUS, lb=0, name="w")  # weights for bonds
    x = model.addVars(N, vtype=GRB.BINARY, name="x")  # binary selection of bonds
    VaR = model.addVar(vtype=GRB.CONTINUOUS, name="VaR")  # Value at Risk variable
    z = model.addVars(N, vtype=GRB.CONTINUOUS, lb=0, name="z")  # Auxiliary for CVaR

    # Constrain the total weight
    model.addConstr(quicksum(w[i] for i in range(N)) <= W_max, "MaxWeight")
    model.addConstr(quicksum(w[i] for i in range(N)) == 1, "WeightSum")

    # Deviation from benchmark

    deviation_limit = 0.1  # 10% deviation
    BenchmarkWeight = 0.01  # 1% in each bond

    for i in range(N):
        model.addConstr(w[i] >= BenchmarkWeight - deviation_limit*BenchmarkWeight)
        model.addConstr(w[i] <= BenchmarkWeight + deviation_limit*BenchmarkWeight)


    # VaR constraint
    model.addConstr(VaR >= quicksum(w[i] * expected_returns[i] for i in range(N)), "VaRDef")

    expected_returns = quicksum(bond_data.iloc[i]['expected_return'] * x[i] for i in range(N))
    
    # CVaR calculation (assuming 'returns' is a list of returns for each bond)
    CVaR_penalty = quicksum(z[i] for i in range(N))  # Sum of CVaR penalties
    
    # Set the objective: maximize expected return minus lambda * CVaR penalty
    model.setObjective(expected_returns - lambda_penalty * CVaR_penalty, GRB.MAXIMIZE)

    # CVaR auxiliary constraints
    for i in range(N):
        model.addConstr(z[i] >= w[i] - VaR, "CVaR_Aux" + str(i))

    # OAS Constraints

    weighted_OAS = quicksum(bond_data.iloc[i]['OAS'] * w[i] for i in range(N))
    benchmark_OAS = sum(0.01 * bond_data.iloc[i]['OAS'] for i in range(N))  # 1% in each bond
    print("benchmark OAS: ", benchmark_OAS)
    lower_bound = 0.9 * benchmark_OAS
    upper_bound = 1.1 * benchmark_OAS

    model.addConstr(weighted_OAS >= lower_bound, name="OAS_LowerBound")
    model.addConstr(weighted_OAS <= upper_bound, name="OAS_UpperBound")


    # Liquidity Constraint
    Liquidity = quicksum(bond_data.iloc[i]['liquidity_score'] for i in range(N)) / N
    MinLiquidity = 0.9 * Liquidity
    model.addConstr(quicksum(bond_data.iloc[i]['liquidity_score'] * w[i] for i in range(N)) >= MinLiquidity, "MinLiquidity")

    # Transaction Cost Constraints
    Benchmark_cost = quicksum(bond_data.iloc[i]['transaction_cost'] for i in range(N)) / N
    lower_t_cost = 0.9 * Benchmark_cost
    upper_t_cost = 1.1 * Benchmark_cost

    model.addConstr(quicksum(bond_data.iloc[i]['transaction_cost'] * x[i] for i in range(N)) >= lower_t_cost, "MinTCost")
    model.addConstr(quicksum(bond_data.iloc[i]['transaction_cost'] * x[i] for i in range(N)) <= upper_t_cost, "MaxTCost")


    # Optimize the model
    model.optimize()

    if model.status == GRB.OPTIMAL:
        #print("Optimal solution found. List of all weights:")
        weights = [w[i].X for i in range(N)]  # Get the optimized weights for bonds
        return np.array(weights)

    if model.status == GRB.INFEASIBLE:
        print("The model is infeasible.")


